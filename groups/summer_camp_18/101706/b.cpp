#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long double type;
//for big coordinates change to long long

//BASICS
  bool ge(type x, type y) { return x + EPS > y; }
  bool le(type x, type y) { return x - EPS < y; }
  bool eq(type x, type y) { return ge(x, y) and le(x, y); }

  struct point {
      type x, y;

      point() : x(0), y(0) {}
      point(type x, type y) : x(x), y(y) {}

      point operator -() { return point(-x, -y); }
      point operator +(point p) { return point(x+p.x, y+p.y); }
      point operator -(point p) { return point(x-p.x, y-p.y); }

      point operator *(type k) { return point(k*x, k*y); }
      point operator /(type k) { return point(x/k, y/k); }

      type operator *(point p) { return x*p.x + y*p.y; }
      type operator %(point p) { return x*p.y - y*p.x; }

      bool operator ==(point p) { return x == p.x and y == p.y; }
      bool operator !=(point p) { return x != p.x  or y != p.y; }
      bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

      int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
      }

      bool on_seg(point p, point q) {
          if (this->dir(p, q)) return 0;
          return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
              ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
      }

      ld abs() { return sqrt(x*x + y*y); }
      type abs2() { return x*x + y*y; }
      ld dist(point q) { return (*this - q).abs(); }
      type dist2(point q) { return (*this - q).abs2(); }

      ld arg() { return atan2l(y, x); }

      // Project point on vector y
      point project(point y) { return y * ((*this * y) / (y * y)); }

      // Project point on line generated by points x and y
      point project(point x, point y) { return x + (*this - x).project(y-x); }

      ld dist_line(point x, point y) { return dist(project(x, y)); }

      ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
      }

      point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
      point rotate(ld a) { return rotate(sin(a), cos(a)); }
      // rotate around the argument of vector p
      point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

  };

  point RotateCCW90(point p)   { return point(-p.y,p.x); }
  point RotateCW90(point p)    { return point(p.y,-p.x); }

  ld dot(point p, point q)     { return p.x*q.x+p.y*q.y; }
  ld cross(point p, point q)   { return p.x*q.y-p.y*q.x; }

  type area2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

  ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
  }

  int direction(point o, point p, point q) { return p.dir(o, q); }

  point ProjectPointLine(point a, point b, point c) {
    return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);
  }

  point ProjectPointSegment(point a, point b, point c) {
    ld r = dot(b-a,b-a);
    if (fabs(r) < EPS) return a;
    r = dot(c-a, b-a)/r;
    if (r < 0) return a;
    if (r > 1) return b;
    return a + (b-a)*r;
  }

  ld DistancePointSegment(point a, point b, point c) {
    return c.dist(ProjectPointSegment(a, b, c));
  }

  ld DistancePointLine(point a, point b, point c) {
    return c.dist(ProjectPointLine(a, b, c));
  }

  bool LinesParallel(point a, point b, point c, point d) { 
    return fabs(cross(b-a, c-d)) < EPS; 
  }

  bool LinesCollinear(point a, point b, point c, point d) { 
    return LinesParallel(a, b, c, d)
        && fabs(cross(a-b, a-c)) < EPS
        && fabs(cross(c-d, c-a)) < EPS; 
  }

   bool SegmentsIntersect(point a, point b, point c, point d) {
    if (LinesCollinear(a, b, c, d)) {
      if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
      if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)
        return false;
      return true;
    }
    if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;
    if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;
    return true;
  }

    point lines_intersect(point p, point q, point a, point b) {
        point r = q-p, s = b-a, c(p%q, a%b);
        if (eq(r%s,0)) return point(INF, INF);
        return point(point(r.x, s.x) % c, point(r.y, s.y) % c) / (r%s);
    }

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    point inter;
    cout << setprecision(10) << fixed;
    point a,b,c,d;
    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y;
    //The distance from the point A to the point C.
    cout << a.dist(c) << "\n";
    //The distance from the point A to the segment CD.
    cout << DistancePointSegment(c,d,a) << "\n";
    //The distance from the point A to the half-infinite ray CD.
    cout << DistancePointSegment(c,d+((d-c)/(d-c).abs())*N,a) << "\n";
    //The distance from the point A to the line CD.
    cout << DistancePointLine(c,d,a) << "\n";
    //The distance from the segment AB to the point C.
    cout << DistancePointSegment(a,b,c) << "\n";
    //The distance from the segment AB to the segment CD.
    if(SegmentsIntersect(a,b,c,d)) cout << 0.0 << "\n";
    else cout << min({DistancePointSegment(c,d,a),DistancePointSegment(c,d,b),DistancePointSegment(a,b,c),DistancePointSegment(a,b,d)}) << "\n";
    //The distance from the segment AB to the half-infinite ray CD.
    inter = lines_intersect(a,b,c,d);
    if(inter.on_seg(a,b) and ge(dot((inter-c),(d-c)), 0)) cout << 0.0 << "\n";
    else cout << min({DistancePointSegment(c,d+(d-c)*N,a),DistancePointSegment(c,d+(d-c)*N,b),DistancePointSegment(a,b,c)}) << "\n";
    //The distance from the segment AB to the line CD.
    inter = lines_intersect(a,b,c,d);
    if(inter.on_seg(a,b)) cout << 0.0 << "\n";
    else cout << min({DistancePointLine(c,d,a),DistancePointLine(c,d,b)}) << "\n";    
    //The distance from the half-infinite ray AB to the point C.
    cout << DistancePointSegment(a,b+(b-a)*N,c) << "\n"; 
    //The distance from the half-infinite ray AB to the segment CD.
    inter = lines_intersect(a,b,c,d);
    if(inter.on_seg(c,d) and ge(dot((inter-a),(b-a)),0)) cout << 0.0 << "\n";
    else cout << min({DistancePointSegment(a,b+(b-a)*N,c),DistancePointSegment(a,b+(b-a)*N,d),DistancePointSegment(c,d,a)}) << "\n";
    //The distance from the half-infinite ray AB to the half-infinite ray CD.
    inter = lines_intersect(a,b,c,d);
    if(dot((inter-a),(b-a)) < 0 or dot((inter-c),(d-c)) < 0) cout << min({DistancePointSegment(c,d+(d-c)*N,a),DistancePointSegment(a,b+(b-c)*N,c)}) << "\n";
    else cout << 0.0 << "\n"; 
    //The distance from the half-infinite ray AB to the line CD.
    inter = lines_intersect(a,b,c,d);
    if(dot((inter-a),(b-a)) < 0) cout << DistancePointLine(c,d,a) << "\n";
    else cout << 0.0 << "\n"; 
    //The distance from the line AB to the point C.
    cout << DistancePointLine(a,b,c) << "\n";
    //The distance from the line AB to the segment CD.
    inter = lines_intersect(a,b,c,d);
    if(inter.on_seg(c,d)) cout << 0.0 << "\n";
    else cout << min({DistancePointLine(a,b,c),DistancePointLine(a,b,d)}) << "\n"; 
    //The distance from the line AB to the half-infinite ray CD.
    inter = lines_intersect(a,b,c,d);
    if(dot((inter-c),(d-c)) < 0) cout << DistancePointLine(a,b,c) << "\n";
    else cout << 0.0 << "\n"; 
    //The distance from the line AB to the line CD.
    if(!LinesParallel(a,b,c,d)) cout << 0.0 << "\n";
    else cout << DistancePointLine(a,b,c) << "\n";

    return 0;
}