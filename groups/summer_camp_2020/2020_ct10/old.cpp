#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long long type;
//for big coordinates change to long long

//BASICS

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x+p.x, y+p.y); }
    point operator -(point p) { return point(x-p.x, y-p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    type operator *(point p) { return x*p.x + y*p.y; }
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(point p) { return x == p.x and y == p.y; }
    bool operator !=(point p) { return x != p.x  or y != p.y; }
    bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

    int dir(point o, point p) {
    type x = (*this - o) % (p - o);
    return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
            ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
    return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }
    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }
};


point RotateCCW90(point p)   { return point(-p.y,p.x); }
point RotateCW90(point p)    { return point(p.y,-p.x); }

ld dot(point p, point q)     { return p.x*q.x+p.y*q.y; }
ld cross(point p, point q)   { return p.x*q.y-p.y*q.x; }

type area2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
}

int direction(point o, point p, point q) { return p.dir(o, q); }

point origin;
point tot[N], ini[N], fim[N];

int above(point p){
    if(p.y == origin.y) return p.x > origin.x;
    return p.y > origin.y;
}

bool cmp(pair<point,pii> a, pair<point,pii> b){
    point p = a.st, q = b.st;
    int tmp = above(q) - above(p);
    if(tmp) return tmp > 0;
    return p.dir(origin,q) > 0;
}

bool LinesParallel(point a, point b, point c, point d) { 
    return fabs(cross(b-a, c-d)) < EPS; 
}

bool LinesCollinear(point a, point b, point c, point d) { 
    return LinesParallel(a, b, c, d)
        && fabs(cross(a-b, a-c)) < EPS
        && fabs(cross(c-d, c-a)) < EPS; 
}

bool SegmentsIntersect(point a, point b, point c, point d) {
    if (LinesCollinear(a, b, c, d)) {
        if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
        if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)
        return false;
        return true;
    }
    if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;
    if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;
    return true;
}

bool cmp2(int a, int b){
    point u = ini[a], v = fim[a];
    point p = ini[b], q = fim[b];
    if (cross(u - origin, p - origin) > 0) return SegmentsIntersect(u, v, origin, p);
    return !SegmentsIntersect(u, origin, p, q);
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    freopen("a.txt", "r", stdin);
    freopen("out2.txt", "w", stdout);
    int s,k,w;
    while(cin >> s >> k >> w){
        for(int i=0;i<k;i++) cin >> tot[i].x >> tot[i].y;
        for(int i=0;i<w;i++) cin >> ini[i].x >> ini[i].y >> fim[i].x >> fim[i].y;
        for(int i=0;i<s;i++){
            origin = tot[i];
            ll ans = 0;
            //adding events to vector
            vector<pair<point,pii>> v;
            //adding children
            for(int j=0;j<k;j++){
                if(i == j) continue;
                v.pb({tot[j],{2,j}});
            }
            //adding walls
            for(int j=0;j<w;j++){
                //depending on children position the initial point of the wall might be the final instead
                if(ini[j].dir(origin,fim[j]) < 0) swap(ini[j],fim[j]);
                v.pb({ini[j],{0,j}});
                v.pb({fim[j],{1,j}});
            }
            //0 : initial point from wall
            //1 : final point from wall
            //2: children

            //radial sort
            sort(v.begin(), v.end(), cmp);
            //look for walls that from the start of the array are already blocking vision
            
            set<int,bool(*)(int,int)> ps(cmp2);
            for(auto u : v){
                if(u.nd.st == 0) ps.insert(u.nd.nd);
                if(u.nd.st == 1) if(ps.count(u.nd.nd)) ps.erase(u.nd.nd);
            }
            
            //0 : initial point from wall
            //1 : final point from wall
            //2: children
            
            for(auto u : v){
                //cout << u.st << "\n";
                if(u.nd.st == 1){
                    if(ps.count(u.nd.nd)) ps.erase(u.nd.nd);
                }
                else if(u.nd.st == 0){
                    ps.insert(u.nd.nd);
                }
                else{
                    if(!ps.size()){
                        ans++;
                    }
                    else{
                        point o = ini[(*ps.begin())];
                        point p = fim[(*ps.begin())];
                        //cout << o << " " << p << "\n";
                        if(!SegmentsIntersect(tot[i],u.st,o,p)){
                            ans++;
                            //cout << o << " " << p << " ";
                            //cout << tot[i] << " " << tot[u.nd.nd] << "\n";
                        }
                    }
                }
            }
            cout << ans << "\n";
        }
    }
    return 0;
}