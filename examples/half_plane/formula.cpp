#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long double type;
//for big coordinates change to long long

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }
int sign(type x) { return ge(x, 0) - le(x, 0); }

struct point {
    type x, y;
    

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x + p.x, y + p.y); }
    point operator -(point p) { return point(x - p.x, y - p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    //inner product
    type operator *(point p) { return x*p.x + y*p.y; }
    //cross product
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(const point &p) const{ return x == p.x and y == p.y; }
    bool operator !=(const point &p) const{ return x != p.x  or y != p.y; }
    bool operator <(const point &p) const { return (x < p.x) or (x == p.x and y < p.y); }

    // 0 => same direction
    // 1 => p is on the left 
    //-1 => p is on the right    
    int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x - sin*y, sin*x + cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }

    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.y / p.abs(), p.x / p.abs()); }

};

int direction(point o, point p, point q) { return p.dir(o, q); }

point rotate_ccw90(point p)   { return point(-p.y,p.x); }
point rotate_cw90(point p)    { return point(p.y,-p.x); }

//for reading purposes avoid using * and % operators, use the functions below:
type dot(point p, point q)     { return p.x*q.x + p.y*q.y; }
type cross(point p, point q)   { return p.x*q.y - p.y*q.x; }

//double area
type area_2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

int angle_less(const point& a1, const point& b1, const point& a2, const point& b2) {
    //angle between (a1 and b1) vs angle between (a2 and b2)
    //1  : bigger
    //-1 : smaller
    //0  : equal
    point p1(dot(   a1, b1), abs(cross(   a1, b1)));
    point p2(dot(   a2, b2), abs(cross(   a2, b2)));
    if(cross(p1, p2) < 0) return 1;
    if(cross(p1, p2) > 0) return -1;
    return 0;
}

ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
}

struct Segment {
	typedef long double T;
	point p1, p2;
	T a, b, c;

	Segment() {}

	Segment(point be, point en) {
		p1 = be, p2 = en;
		a = -(be.y - en.y);
		b = be.x - en.x;
		c = a * en.x + b * en.y;
	}

	T plug(T x, T y) {
		// plug >= 0 is to the right
		return a * x + b * y - c;
	}

	T plug(point p) {
		return plug(p.x, p.y);
	}

	bool inLine(point p) { return (p - p1) % (p2 - p1) == 0; }
	bool inSegment(point p) {
		return inLine(p) && (p1 - p2) * (p - p2) >= 0 && (p2 - p1) * (p - p1) >= 0;
	}

	point lineIntersection(Segment s) {
		long double A = a, B = b, C = c;
		long double D = s.a, E = s.b, F = s.c;
		long double x = (long double) C * E - (long double) B * F;
		long double y = (long double) A * F - (long double) C * D;
		long double tmp = (long double) A * E - (long double) B * D;
		x /= tmp;
		y /= tmp;
		return point(x, y);
	}
	
	bool polygonIntersection(const std::vector<point> &poly) {
		long double l = -1e18, r = 1e18;
		for(auto p : poly) {
			long double z = plug(p);
			l = std::max(l, z);
			r = std::min(r, z);
		}
		return l - r > EPS;
	}
};

typedef vector<point> polygon;

// bool cutPolygon(std::vector<point> poly, Segment seg) {
// 	int n = (int) poly.size();
// 	std::vector<point> ans;
// 	for(int i = 0; i < n; i++) {
// 		double z = seg.plug(poly[i]);
//         db(z);
// 		if(z > -EPS) {
// 			ans.push_back(poly[i]);
// 		}
//         else return false;
// 		double z2 = seg.plug(poly[(i + 1) % n]);
//         db(z _ z2);
// 		if((z > EPS && z2 < -EPS) || (z < -EPS && z2 > EPS)) {
// 			ans.push_back(seg.lineIntersection(Segment(poly[i], poly[(i + 1) % n])));
//             return false;
//         }
// 	}
// 	return true;
// }

bool point_in_triangle(point a, point b, point c, point cur){
    ld s1 = abs(cross(b - a, c - a));
    ld s2 = abs(cross(a - cur, b - cur)) + abs(cross(b - cur, c - cur)) + abs(cross(c - cur, a - cur));
    return eq(s1, s2);
}

void sort_lex_hull(vector<point> &hull){
    int n = hull.size();

    //Sort hull by x
    int pos = 0;
    for(int i = 1; i < n; i++) if(hull[i] <  hull[pos]) pos = i;
    rotate(hull.begin(), hull.begin() + pos, hull.end());
}

//determine if point is inside or on the boundary of a polygon (O(logn))
bool point_in_convex_polygon(vector<point> &hull, point cur){
    int n = hull.size();
    //Corner cases: point outside most left and most right wedges
    if(cur.dir(hull[0], hull[1]) != 0 && cur.dir(hull[0], hull[1]) != hull[n - 1].dir(hull[0], hull[1]))
        return false;
    if(cur.dir(hull[0], hull[n - 1]) != 0 && cur.dir(hull[0], hull[n - 1]) != hull[1].dir(hull[0], hull[n - 1]))
        return false;

    //Binary search to find which wedges it is between
    int l = 1, r = n - 1;
    while(r - l > 1){
        int mid = (l + r)/2;
        if(cur.dir(hull[0], hull[mid]) <= 0)l = mid;
        else r = mid;
    }
    return point_in_triangle(hull[l], hull[l + 1], hull[0], cur);
}


// Intersection of halfplanes - O(nlogn)
// Points are given in counterclockwise order
//
// by Agnez

int cmp(ld x, ld y = 0, ld tol = EPS) {
    return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1; }

bool comp(point a, point b){
    if((cmp(a.x) > 0 || (cmp(a.x) == 0 && cmp(a.y) > 0) ) && (cmp(b.x) < 0 || (cmp(b.x) == 0 && cmp(b.y < 0)))) return 1;
    if((cmp(b.x) > 0 || (cmp(b.x) == 0 && cmp(b.y) > 0) ) && (cmp(a.x) < 0 || (cmp(a.x) == 0 && cmp(a.y < 0)))) return 0;
    ll R = a%b;
    if(R) return R > 0;
    return false;
}

namespace halfplane{
  struct L{
    point p,v;
    L(){}
    L(point P, point V):p(P),v(V){}
    bool operator<(const L &b)const{ return comp(v, b.v); }
  };
  vector<L> line;
  void addL(point a, point b){line.pb(L(a,b-a));}
  bool left(point &p, L &l){ return cmp(l.v % (p-l.p))>0; }
  bool left_equal(point &p, L &l){ return cmp(l.v % (p-l.p))>=0; }
  void init(){ line.clear(); }

  point pos(L &a, L &b){
    point x=a.p-b.p;
    ld t = (b.v % x)/(a.v % b.v);
    return a.p+a.v*t;
  }

  polygon intersect(){
    sort(line.begin(), line.end());
    deque<L> q; //linhas da intersecao
    deque<point> p; //pontos de intersecao entre elas
    q.push_back(line[0]);
    for(int i=1; i < (int) line.size(); i++){
      while(q.size()>1 && !left(p.back(), line[i]))
        q.pop_back(), p.pop_back();
      while(q.size()>1 && !left(p.front(), line[i]))
        q.pop_front(), p.pop_front();
      if(!cmp(q.back().v % line[i].v) && !left(q.back().p,line[i]))
        q.back() = line[i];
      else if(cmp(q.back().v % line[i].v))
        q.push_back(line[i]), p.push_back(point());
      if(q.size()>1)
        p.back()=pos(q.back(),q[q.size()-2]);
    }
    while(q.size()>1 && !left(p.back(),q.front()))
      q.pop_back(), p.pop_back();
    if(q.size() <= 2) {return polygon();} //Nao forma poligono (pode nao ter intersecao)
    if(!cmp(q.back().v % q.front().v)) {return polygon();} //Lados paralelos -> area infinita
    point ult = pos(q.back(),q.front());

    bool ok = 1;
    for(int i=0; i < (int) line.size(); i++)
      if(!left_equal(ult,line[i])){ ok=0; break; }

    if(ok) p.push_back(ult); //Se formar um poligono fechado
    polygon ret;
    for(int i=0; i < (int) p.size(); i++)
      ret.pb(p[i]);
    return ret;
  }
};

ld compute_signed_area(const polygon &p) {
    ld area = 0;
    for(int i = 0; i < p.size(); i++) {
        int j = (i+1) % p.size();
        area += p[i].x*p[j].y - p[j].x*p[i].y;
    }
    return area / 2.0;
}

ld compute_area(const polygon &p) {
    return fabs(compute_signed_area(p));
}

polygon pts[2], old;
int n[2];
ld area;

bool check(ld mid){
    halfplane::init();
    for(int i = 0; i < n[1]; i++) halfplane::addL(pts[1][i], pts[1][(i + 1)%n[1]]);
    for(int j = 0; j < n[0]; j++){
        point dir = rotate_ccw90(pts[0][(j + 1)%n[0]] - pts[0][j]);
        dir = (dir/(dir.abs())) * mid;
        halfplane::addL(pts[0][j] + dir, pts[0][(j + 1)%n[0]] + dir);
        db((pts[0][j] + dir) _ (pts[0][(j + 1)%n[0]] + dir));
        // db(dir);
        // cout << pts[0][j] + dir << pts[0][(j + 1)%n[0]] + dir << "\n";
        // polygon cur = halfplane::intersect();
        // ld tmp = compute_area(cur);
        // db(cur.size());
        // if(cur.size() and !eq(tmp, area)) return false;
        // halfplane::line.pop_back();
    }
    polygon cur = halfplane::intersect();
    sort_lex_hull(cur);
    for(auto d : old) if(point_in_convex_polygon(cur, d)) return false;
    ld tmp = compute_area(cur);
    // db(mid _ tmp _ area);
    return true;
}

int main(){
    for(int i = 0; i < 2; i++){
        cin >> n[i];
        pts[i].resize(n[i]);
        for(int j = 0; j < n[i]; j++){
            cin >> pts[i][j].x >> pts[i][j].y;
        }
    }
    // for(int i = 0; i < n[0]; i++) halfplane::addL(pts[0][i], pts[0][(i + 1)%n[0]]);
    // cur = halfplane::intersect();
    // for(int i = 0; i < n[1]; i++) halfplane::addL(pts[1][i], pts[1][(i + 1)%n[1]]);
    // area = compute_area(halfplane::intersect());
    // db(area);
    // db(check(0));
    // polygon cur = halfplane::intersect();
    // for(auto c : cur) cout << c << "\n";
    // old = cur;
    ld l = 0, r = 1000;
    while(r - l > EPS){
        ld mid = (r + l) / 2;
        db(check(mid));
        if(check(mid)) l = mid;
        else r = mid;
    }
    cout << setprecision(15) << fixed << l/2 << "\n";
    return 0;
}