/*idea:
    first insight: points from convex hull will be borders of the answer
    using this insight, we are going to build the answer, from 1 rubber band to b rubber bands, as a dp
    dp[1] is the area of the convex hull
    to build the answer for each value, we are going to cut edges from the convex hull, searching for the best edge to cut
*/

#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<pii, int> piii;
typedef pair<ll,ll> pll;
typedef pair<pll, ll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef int type;
//for big coordinates change to long long

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x + p.x, y + p.y); }
    point operator -(point p) { return point(x - p.x, y - p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    //inner product
    type operator *(point p) { return x*p.x + y*p.y; }
    //cross product
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(const point &p) const{ return x == p.x and y == p.y; }
    bool operator !=(const point &p) const{ return x != p.x  or y != p.y; }
    bool operator <(const point &p) const { return (x < p.x) or (x == p.x and y < p.y); }

    // 0 => same direction
    // 1 => p is on the left 
    //-1 => p is on the right    
    int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x - sin*y, sin*x + cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }

    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

};

int direction(point o, point p, point q) { return p.dir(o, q); }

point rotate_ccw90(point p)   { return point(-p.y,p.x); }
point rotate_cw90(point p)    { return point(p.y,-p.x); }

//for reading purposes avoid using * and % operators, use the functions below:
type dot(point p, point q)     { return p.x*q.x + p.y*q.y; }
type cross(point p, point q)   { return p.x*q.y - p.y*q.x; }

//double area
type area_2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

point origin;
int above(point p){
    if(p.y == origin.y) return p.x > origin.x;
    return p.y > origin.y;
}

bool cmp(point p, point q){
    int tmp = above(q) - above(p);
    if(tmp) return tmp > 0;
    return p.dir(origin,q) > 0;
    //Be Careful: p.dir(origin,q) == 0
}

//Monotone chain O(nlog(n))
void monotone_hull(vector<point> &pts) {
    sort(pts.begin(), pts.end());
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    vector<point> up, dn;
    for (int i = 0; i < pts.size(); i++) {
        while (up.size() > 1 && area_2(up[up.size()-2], up.back(), pts[i]) >= 0) up.pop_back();
        while (dn.size() > 1 && area_2(dn[dn.size()-2], dn.back(), pts[i]) <= 0) dn.pop_back();
        up.push_back(pts[i]);
        dn.push_back(pts[i]);
    }
    pts = dn;
    for (int i = (int) up.size() - 2; i >= 1; i--) pts.push_back(up[i]);
}

//avoid using long double for comparisons, change type and remove division by 2
int compute_signed_area(const vector<point> &p) {
    int area = 0;
    for(int i = 0; i < p.size(); i++) {
        int j = (i+1) % p.size();
        area += p[i].x*p[j].y - p[j].x*p[i].y;
    }
    return area;
}


int main(){
    while(true){
        //read
        int b, n;
        scanf("%d%d", &b, &n);
        if(!b and !n) return 0;
        --n;
        vector<point> hull(n), pts(n);
        vector<int> dp(b + 1);
        scanf("%d%d", &origin.x, &origin.y);
        for(int i = 0; i < n; i++){
            scanf("%d%d", &pts[i].x, &pts[i].y);
            hull[i] = pts[i];
        }
        //convex hull of all points, except origin
        monotone_hull(hull);
        
        //sort points radially
        sort(pts.begin(), pts.end(), cmp);
        //duplicate vector
        pts.resize(2 * n);
        for(int i = 0; i < n; i++) pts[i + n] = pts[i];
        //mark positions of the hull points in the vector of all points
        vector<int> pos;
        for(int i = 0; i < n; i++){
            for(auto p : hull) if(p == pts[i]) pos.push_back(i);
        }
        //calculate best cut for edges from the hull
        vector<int> ans(2 * n);
        for(int i = 0; i < pos.size(); i++){
            //remember its counter clockwise!
            //separate hull in two hulls:
            //hull_right: l -> j
            //hull_left: j + 1 -> r
            int l = pos[i], r = pos[(i + 1) % pos.size()];
            if(r < l) r += n;
            for(int j = l; j < r; j++){
                vector<point> hull_left, hull_right;
                //hull_right
                hull_right.push_back(origin), hull_right.push_back(pts[l]);
                for(int k = l + 1; k <= j; k++){
                    while(hull_right[hull_right.size() - 1].dir(hull_right[hull_right.size() - 2], pts[k]) < 1) hull_right.pop_back();
                    hull_right.push_back(pts[k]);
                }
                //hull_left
                hull_left.push_back(origin), hull_left.push_back(pts[r]);
                for(int k = r - 1; k > j; k--){
                    while(hull_left[hull_left.size() - 1].dir(hull_left[hull_left.size() - 2], pts[k]) > 1) hull_left.pop_back();
                    hull_left.push_back(pts[k]);
                }
                int area_l = abs(compute_signed_area(hull_left));
                int area_r = abs(compute_signed_area(hull_right));
                int tot = abs(area_2(pts[l], pts[r], origin));
                ans[(j % n)] = max(ans[(j % n)], tot - area_l - area_r);
            }
        }
        set<int> cut, cant;
        dp[1] = abs(compute_signed_area(hull));
        for(int i = 2; i <= b; i++){
            dp[i] = dp[i - 1];
            piii dif1 = {{0, -1}, -1}, dif2 = {{0, -1}, -1};
            //if edge from convex hull is not cut, try to cut it
            for(int j = 0; j < pos.size(); j++){
                if(cut.count(j)) continue;
                int l = pos[j], r = pos[(j + 1)%pos.size()];
                if(r < l) r += n;
                if(cant.count((l % n))) l++;
                if(cant.count((r % n))) r--;
                for(int k = l; k < r; k++){
                    dif1 = max(dif1, {{ans[k % n], j}, k});
                }
            }
            dp[i] -= dif1.st.st;
            cut.insert(dif1.nd);
            cant.insert(dif1.nd % n), cant.insert((dif1.nd + 1)%n);
            //for i == 2, two edges need to be cut
            if(i == 2){
                for(int j = 0; j < pos.size(); j++){
                    if(cut.count(j)) continue;
                    int l = pos[j], r = pos[(j + 1)%pos.size()];
                    if(r < l) r += n;
                    if(cant.count((l % n))) l++;
                    if(cant.count((r % n))) r--;
                    for(int k = l; k < r; k++){
                        dif2 = max(dif2, {{ans[k % n], j}, k});
                    }
                }
                cant.insert(dif2.nd % n), cant.insert((dif2.nd + 1) % n);
                dp[i] -= dif2.st.st;
                cut.insert(dif2.nd);
            }
        }
        printf("%d%s", dp[b]/2, ((dp[b]%2) ? ".50\n" : ".00\n"));
    }
    return 0;
}