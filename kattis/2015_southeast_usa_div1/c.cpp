#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld /*EPS = 1e-9,*/ PI = acos(-1.);
const double EPS = 1e-7;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef double type;

int n;

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x+p.x, y+p.y); }
    point operator -(point p) { return point(x-p.x, y-p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    type operator *(point p) { return x*p.x + y*p.y; }
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(point p) { return x == p.x and y == p.y; }
    bool operator !=(point p) { return x != p.x  or y != p.y; }
    bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

    int dir(point o, point p) {
    type x = (*this - o) % (p - o);
    return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
            ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    double abs() { return sqrt((ld)x*x + (ld)y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
    return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }
    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

};

point RotateCCW90(point p)   { return point(-p.y,p.x); }
point RotateCW90(point p)    { return point(p.y,-p.x); }

struct circle {
    point c;
    double r;
    circle() { c = point(); r = 0; }
    circle(point _c, double _r) : c(_c), r(_r) {}
    double area() { return acos(-1.0)*r*r; }
    double chord(double rad) { return  2*r*sin(rad/2.0); }
    double sector(double rad) { return 0.5*rad*area()/acos(-1.0); }
    bool intersects(circle other) {
        return le(c.dist(other.c), r + other.r);
    }
    bool contains(point p) { return c.dist(p) <= r + EPS; }
    pair<point, point> getTangentPoint(point p) {
        double d1 = c.dist(p), theta = asin(r/d1);
        point p1 = (c-p).rotate(-theta);
        point p2 = (c-p).rotate(theta);
        p1 = p1*(sqrt(d1*d1-r*r)/d1)+p;
        p2 = p2*(sqrt(d1*d1-r*r)/d1)+p;
        return make_pair(p1,p2);
    }
};

vector<point> inter;
circle v[N], dv[N];
vi adj[N];
int vis[N], cmp[N], cnt, ans = 0, vis2[N];

vector<point> CircleCircleIntersection(point a, point b, double r, double R) {
    vector<point> ret;
    double d = a.dist(b);
    if (!le(d, r+R) || !ge(d+min(r, R), max(r, R))) return ret;
    double x = (d*d-R*R+r*r)/(2*d);
    double y = sqrt(r*r-x*x);
    point v = (b-a)/(d + EPS);
    ret.push_back(a+v*x + RotateCCW90(v)*y);
    if (y > 0)
        ret.push_back(a+v*x - RotateCCW90(v)*y);
    return ret;
}

void dfs(int s){
    vis[s] = cnt;
    cmp[cnt]++;
    for(auto v: adj[s]){
        if(!vis[v]){
            dfs(v);
        }
    }
}

int main(){
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        point p;
        scanf("%lf%lf", &p.x, &p.y);
        v[i] = circle(p, 1.0);
        dv[i] = circle(p, 2.0);
    }
    
    for(int i = 0; i < n; i++){
        for(int j = i + 1; j < n; j++){
            if(v[i].intersects(v[j])){
                adj[i].pb(j);
                adj[j].pb(i);
            }
            else{
                vector<point> tmp = CircleCircleIntersection(dv[i].c, dv[j].c, dv[i].r, dv[j].r);
                for(auto p : tmp) inter.pb(p);
            }
        }
    }

    for(int i = 0; i < n; i++){
        if(!vis[i]){
            cnt++;
            dfs(i);
        }
        ans = max(ans, cmp[vis[i]] + 1);
    }

    for(auto p : inter){
        int tmp = 1;
        vi usado;
        circle cur = circle(p, 1.0);
        for(int i = 0; i < n; i++){
            if(v[i].intersects(cur)){
                if(!vis2[vis[i]]){
                    vis2[vis[i]] = 1;
                    usado.pb(vis[i]);
                    tmp += cmp[vis[i]];
                }
            }
        }
        for(auto u : usado) vis2[u] = 0;
        ans = max(ans, tmp);
    }
    printf("%d\n", ans);
    return 0;
}