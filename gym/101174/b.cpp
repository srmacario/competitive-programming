#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long long type;
//for big coordinates change to long long

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x + p.x, y + p.y); }
    point operator -(point p) { return point(x - p.x, y - p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    //inner product
    type operator *(point p) { return x*p.x + y*p.y; }
    //cross product
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(const point &p) const{ return x == p.x and y == p.y; }
    bool operator !=(const point &p) const{ return x != p.x  or y != p.y; }
    bool operator <(const point &p) const { return (x < p.x) or (x == p.x and y < p.y); }

    // 0 => same direction
    // 1 => p is on the left 
    //-1 => p is on the right    
    int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x - sin*y, sin*x + cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }

    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

};

point origin;

int above(point p){
    if(p.y == origin.y) return p.x > origin.x;
    return p.y > origin.y;
}

bool cmp(pair<point, int> a, pair<point, int> b){
    point p = a.st;
    point q = b.st;
    int tmp = above(q) - above(p);
    if(tmp) return tmp > 0;
    // db(p.dir(origin, q));
    if(p.dir(origin, q) == 0) return a.nd < b.nd;
    return p.dir(origin,q) > 0;
}

int n, dummy, pos, start, final_dummy, good_dummy, bad_dummy;
point pts[N], ini;
//first -> aumenta, second -> diminui

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> n;
    cin >> ini.x >> ini.y;
    start = n;
    vector<pair<point, int>> eve;
    for(int i = 0; i < n - 1; i++){
        cin >> pts[i].x >> pts[i].y;
        ll w1 = (ini.x - pts[i].x), w2 = -(ini.y - pts[i].y);
        if(w1 > 0){
            start--;
        }
        //comeÃ§am igual, posso usar tanto pra aumentar quanto pra diminuir
        if(w1 == 0 and w2 == 0) dummy++;
        else if(w2 == 0){
            final_dummy++;
        }
        else if(w1 * w2 >= 0){
            if(w1 > 0) eve.push_back({point(w1, w2), 1});
            if(w1 < 0) eve.push_back({point(-w1, -w2), -1});
            if(w1 == 0){
                if(w2 < 0) good_dummy++;
                if(w2 > 0) bad_dummy++;
            }
        }
    }
    db(start _ eve.size() _ final_dummy _ good_dummy _ bad_dummy);
    //search for best
    pos = start;
    sort(eve.begin(), eve.end(), cmp);
    pos -= dummy;
    int best = pos - (good_dummy + bad_dummy);
    pos = pos + good_dummy - bad_dummy;
    best = min(best, pos);
    for(int i = 0; i < eve.size(); i++){
        // db(pos);
        db(eve[i].st.x _ eve[i].st.y _ eve[i].nd);
        db(((ld)eve[i].st.y/eve[i].st.x));
        pos += eve[i].nd;
        best = min(best, pos);
        //change order of processing for next sweep, to find worst
        eve[i].nd *= -1;
    }
    db(pos);
    best = min(best, pos - final_dummy);
    cout << max(best, 1) << " ";

    //search for worst
    pos = start;
    sort(eve.begin(), eve.end(), cmp);
    int worst = pos;
    for(auto e : eve){
        pos -= e.nd;
        worst = max(worst, pos);
    }
    db(pos);
    worst = max(worst, pos);
    cout << min(worst, n) << "\n";
    return 0;
}