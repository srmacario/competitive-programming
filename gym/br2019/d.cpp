#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e3+5;

typedef long long type;
//for big coordinates change to long long

//BASICS

  bool ge(type x, type y) { return x + EPS > y; }
  bool le(type x, type y) { return x - EPS < y; }
  bool eq(type x, type y) { return ge(x, y) and le(x, y); }

  struct point {
      type x, y;

      point() : x(0), y(0) {}
      point(type x, type y) : x(x), y(y) {}

      point operator -() { return point(-x, -y); }
      point operator +(point p) { return point(x+p.x, y+p.y); }
      point operator -(point p) { return point(x-p.x, y-p.y); }

      point operator *(type k) { return point(k*x, k*y); }
      point operator /(type k) { return point(x/k, y/k); }

      type operator *(point p) { return x*p.x + y*p.y; }
      type operator %(point p) { return x*p.y - y*p.x; }

      bool operator ==(point p) { return x == p.x and y == p.y; }
      bool operator !=(point p) { return x != p.x  or y != p.y; }
      bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

      int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
      }

      bool on_seg(point p, point q) {
          if (this->dir(p, q)) return 0;
          return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
              ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
      }

      ld abs() { return sqrt(x*x + y*y); }
      type abs2() { return x*x + y*y; }
      ld dist(point q) { return (*this - q).abs(); }
      type dist2(point q) { return (*this - q).abs2(); }

      ld arg() { return atan2l(y, x); }

      // Project point on vector y
      point project(point y) { return y * ((*this * y) / (y * y)); }

      // Project point on line generated by points x and y
      point project(point x, point y) { return x + (*this - x).project(y-x); }

      ld dist_line(point x, point y) { return dist(project(x, y)); }

      ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
      }

      point rotate(ld sin, ld cos) { return point(cos*x - sin*y, sin*x + cos*y); }
      point rotate(ld a) { return rotate(sin(a), cos(a)); }
      // rotate around the argument of vector p
      point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

  };

  ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
  }

  point RotateCCW90(point p)   { return point(-p.y,p.x); }
  point RotateCW90(point p)    { return point(p.y,-p.x); }

int n, pwr[N];
point pts[N], origin;
pair<point, point> interval[N];

int above(point p){
    if(p.y == origin.y) return p.x > origin.x;
    return p.y > origin.y;
}

bool cmp(point p, point q){
    int tmp = above(q) - above(p);
    if(tmp) return tmp > 0;
    return p.dir(origin,q) > 0;
}

bool cmp2(pair<pair<int,point>, int> a, pair<pair<int,point>, int> b){
    point p = a.st.nd, q = b.st.nd;
    if(p == q) return a.st.st < b.st.st;
    int tmp = above(q) - above(p);
    if(tmp) return tmp > 0;
    if(p.dir(origin, q) == 0) return a.st.st < b.st.st;
    return p.dir(origin,q) > 0;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> n;
    for(int i = 0; i < n; i++){
        interval[i].st.x = interval[i].st.y = INF;
        interval[i].nd.x = interval[i].nd.y = INF;
    }
    for(int i = 0; i < n; i++){
        cin >> pts[i].x >> pts[i].y >> pwr[i];
    }
    //open, point, id
    vector<pair<pair<int,point>, int>> sweep;
    vi used, aberto;
    // sort(pts, pts + n);
    for(int i = 0; i < n; i++){
        //making constellation for i
        for(int j = 0; j < n; j++){
            if(pwr[i] <= pwr[j]) continue;
            point d = (pts[j] - pts[i]);
            used.pb(0), aberto.pb(0);
            sweep.pb({{0, RotateCW90(d)}, (int)used.size()-1});
            sweep.pb({{1, RotateCCW90(d)}, (int)used.size()-1});
        }
    }
    origin = point(0,0);
    int cnt = 0;
    sort(sweep.begin(), sweep.end(), cmp2);
    for(int i = 0; i < sweep.size(); i++){
        // cout << sweep[i].st.st << " " << sweep[i].st.nd << " " << sweep[i].nd << "\n";
        if(sweep[i].st.st == 0) used[sweep[i].nd] = 1;
        else{
            if(!used[sweep[i].nd]) aberto[sweep[i].nd] = 1, cnt++;
        }
    }
    if(cnt == used.size()){
        cout << "Y\n";
        return 0;
    }
    for(int i = 0; i < sweep.size(); i++){
        if(sweep[i].st.st == 0){
            aberto[sweep[i].nd] = 1, cnt++;
            if(cnt == used.size()){
                cout << "Y\n";
                return 0;
            }
        }
        else{
            aberto[sweep[i].nd] = 0, cnt--;
        }
    }
    cout << "N\n";
    return 0;
}