#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 1e5+5;

typedef long double type;
//for big coordinates change to long long

//BASICS

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x+p.x, y+p.y); }
    point operator -(point p) { return point(x-p.x, y-p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    type operator *(point p) { return x*p.x + y*p.y; }
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(point p) { return x == p.x and y == p.y; }
    bool operator !=(point p) { return x != p.x  or y != p.y; }
    bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

    int dir(point o, point p) {
    type x = (*this - o) % (p - o);
    return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
            ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
    return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }
    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }

};


point RotateCCW90(point p)   { return point(-p.y,p.x); }
point RotateCW90(point p)    { return point(p.y,-p.x); }

double dot(point p, point q)     { return p.x*q.x+p.y*q.y; }
double cross(point p, point q)   { return p.x*q.y-p.y*q.x; }

type area2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }

ostream &operator<<(ostream &os, const point &p) {
os << "(" << p.x << "," << p.y << ")"; 
return os;
}

int direction(point o, point p, point q) { return p.dir(o, q); }

point pts[N];
//farc = ponto mais distante a esquerda
//farcc = ponto mais distante a direita
int farc[N], farcc[N];

pll ternary_search(ll l, ll r, ll lm, ll rm){
    while(r - l > 10) {
        ll m1 = (l+r)/2;
        ll m2 = (l+r)/2 + 1;
        ll f1 = area2(pts[lm],pts[rm],pts[m1]);     
        ll f2 = area2(pts[lm],pts[rm],pts[m2]);      
        if (f1 < f2)
            l = m1;
        else if(f1 > f2)
            r = m2;
        else
            l = m1, r = m2;
    }
    pll ans = {0,-1};
    for(int i=l;i<=r;i++){
        ll aux = area2(pts[lm], pts[rm], pts[i]);
        ans = max(ans,{aux,i});
    }
    return ans;
}

int st[4*N], v[N], lazy[4*N];

void build (int p, int l, int r) {
    if (l == r) {st[p] = v[l]; return;}
    build (2*p, l, (l+r)/2);
    build (2*p+1, (l+r)/2+1, r);
    st[p] = st[2*p]+st[2*p+1];
}

void push (int p, int l, int r) {
    if (lazy[p]) {
        st[p] += (r-l+1)*lazy[p];
        if (l != r) {
            lazy[2*p] += lazy[p];
            lazy[2*p+1] += lazy[p];
        }
        lazy[p] = 0;
    }
}

int query (int p, int l, int r, int i, int j) {
    push(p, l, r);
    if (r < i or j < l) return 0;
    if (i <= l and r <= j) return st[p];
    int x = query(2*p, l, (l+r)/2, i, j);
    int y = query(2*p+1, (l+r)/2+1, r, i, j);
    return x+y;
}

void update (int p, int l, int r, int i, int j, int k) {
    push(p, l, r);
    if (r < i or j < l) return;
    if (i <= l and r <= j) {
        lazy[p] += k;
        push(p, l, r);
        return;
    }
    update(2*p, l, (l+r)/2, i, j, k);
    update(2*p+1, (l+r)/2+1, r, i, j, k);
    if (l != r) st[p] = st[2*p] + st[2*p+1];
}


int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int n;
    cin >> n;
    for(int i=0;i<n;i++) cin >> pts[i].x >> pts[i].y;
    for(int l = 0; l < n; l++){
        int r = (l+1) % n;
        pll mx = ternary_search(0, l, l, r);
        mx = max(mx,ternary_search(r, n-1, l, r));
        farc[l] = farcc[l] = mx.nd;
        if(area2(pts[l], pts[r], pts[farc[l]]) == area2(pts[l], pts[r], pts[(farc[l] + 1)%n])){
            farcc[l] = farc[l];
            farc[l] = (farc[l] + 1) % n;
        }
        if(area2(pts[l], pts[r], pts[farc[l]]) == area2(pts[l], pts[r], pts[(farc[l] - 1 + n)%n])){
            farcc[l] = (farc[l] - 1 + n) % n;
        }
        db(l _ farc[l] _ farcc[l]);
    }
    int from = -1;
    int ans = 0;
    for(int i = 0; i <= 0; i++){
        int j = n-1;
        while(j >= farc[i]){
            int tj = max(0,farcc[i] - farc[j]);
            if(tj == 0) from = j;
            db(tj _ j);
            update(1,1,n,j,j,tj);
            j--;
            ans += tj;
        }
    }
    for(int i = n-1; i > 1; i--){
        if(farc[i] != farcc[i]) update(1,1,n,farc[(i+1)%n],from-1,-1);
        if(farc[(i+1)%n] != farcc[(i+1)%n]){
            int tj = max(0,farcc[i] - farc[farcc[(i+1)%n]]);
            update(1,1,n,i,i,tj);
        }
        ans += query(1,1,n,1,n);
    }
    db(ans);
    return 0;
}