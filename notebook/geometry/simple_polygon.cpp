#include <bits/stdc++.h>
 
using namespace std;
 
#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<
 
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;
 
const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 2e5+5, M = 30, K = 25;
 
typedef long long type;
//for big coordinates change to long long
 
bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }
 
struct point {
    type x, y;
 
    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}
 
    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x + p.x, y + p.y); }
    point operator -(point p) { return point(x - p.x, y - p.y); }
 
    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }
 
    //inner product
    type operator *(point p) { return x*p.x + y*p.y; }
    //cross product
    type operator %(point p) { return x*p.y - y*p.x; }
 
    bool operator ==(const point &p) const{ return x == p.x and y == p.y; }
    bool operator !=(const point &p) const{ return x != p.x  or y != p.y; }
    bool operator <(const point &p) const { return (x < p.x) or (x == p.x and y < p.y); }
 
    // 0 => same direction
    // 1 => p is on the left 
    //-1 => p is on the right    
    int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
    }
 
    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }
 
    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }
 
    ld arg() { return atan2l(y, x); }
 
    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }
 
    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y-x); }
 
    ld dist_line(point x, point y) { return dist(project(x, y)); }
 
    ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) :  min(dist(x), dist(y));
    }
 
    point rotate(ld sin, ld cos) { return point(cos*x - sin*y, sin*x + cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }
 
    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }
 
};
 
int direction(point o, point p, point q) { return p.dir(o, q); }
 
point RotateCCW90(point p)   { return point(-p.y,p.x); }
point RotateCW90(point p)    { return point(p.y,-p.x); }
 
//for reading purposes avoid using * and % operators, use the functions below:
type dot(point p, point q)     { return p.x*q.x + p.y*q.y; }
type cross(point p, point q)   { return p.x*q.y - p.y*q.x; }
 
//double area
type area2(point a, point b, point c) { return cross(a,b) + cross(b,c) + cross(c,a); }
 
ostream &operator<<(ostream &os, const point &p) {
    os << "(" << p.x << "," << p.y << ")"; 
    return os;
}
 
void sort_lex_hull(vector<point> &hull){
    int n = hull.size();
 
    //Sort hull by x
    int pos = 0;
    for(int i = 1; i < n; i++) if(hull[i] <  hull[pos]) pos = i;
    rotate(hull.begin(), hull.begin() + pos, hull.end());
}
 
struct lower_hull{
    point ini, fim;
    int id_ini, id_fim;
 
    lower_hull(point ini = point(LINF, LINF), point fim = point(-LINF, -LINF)) : ini(ini), fim(fim) {
        id_ini = id_fim = -1;
    }
};
 
int n, k[N], p[N], a[N], root;
pii ans;
vector<int> par_upd[N], adj[N];
set<int> paired;
vector <point> hull[N];
pair<point, int> end_hull[N];
lower_hull low[N];
 
struct edge{
    point ini, fim;
    edge(point ini = point(0,0), point fim = point(0,0)) : ini(ini), fim(fim) {}
};
 
bool operator < (const edge& a, const edge& b) {
    if (a.ini == b.ini) return direction(a.ini, a.fim, b.fim) < 0;
    if (a.ini.x < b.ini.x) return direction(a.ini, a.fim, b.ini) < 0;
    return direction(a.ini, b.fim, b.ini) < 0;
}
 
vector <pair<point, piii>> eve;
vector <pair<edge, pii>> edgs[N];
set <pair<edge, pii>> sweep;
 
void is_simple_polygon(){
    int cnt_edge = 0;
    for(int i = 0; i < n; i++){
        for(int j = 0; j < k[i]; j++){
            point l = min(hull[i][j], hull[i][(j + 1)%k[i]]);
            point r = max(hull[i][j], hull[i][(j + 1)%k[i]]);
            //if(l.x != r.x){
                eve.pb({l, {0, {i, j}}});
                eve.pb({r, {1, {i, j}}});
            //}
            edgs[i].pb(make_pair(edge(l, r), make_pair(i, j)));
            cnt_edge++;
        }
    }
    sort(eve.begin(), eve.end());
    for(auto e : eve){
        if(!e.nd.st){
            sweep.insert(edgs[e.nd.nd.st][e.nd.nd.nd]);
        }
        else{
            auto below = sweep.upper_bound(edgs[e.nd.nd.st][e.nd.nd.nd]);
            auto cur = below, above = --cur;
            if(above != sweep.begin() and end_hull[e.nd.nd.st].nd == e.nd.nd.nd){
                --above;
                //if below lower hull then its father is the father from the polygon with edge above
                if(above->nd.nd < low[above->nd.st].id_fim){
                    a[e.nd.nd.st] = above->nd.st;
                    par_upd[above->nd.st].pb(e.nd.nd.st);
                }
                //if below upper hull then it is inside the polygon with edge above
                else{
                    p[e.nd.nd.st] = above->nd.st;
                    paired.insert(e.nd.nd.st);
                }
            }
            sweep.erase(cur);
        }
    }
}
 
int vis[N], h[N], anc[N][M];
 
 
//LCA
void dfs (int u) {
    vis[u] = 1;
    for (auto v : adj[u]) if (!vis[v]) {
        h[v] = h[u]+1;
        anc[v][0] = u;
        dfs(v);
    }
    ans = max(ans, make_pair(h[u], u));
}
 
void build () {
    anc[n][0] = n;
    dfs(n);
    for (int j = 1; j <= K; j++) for (int i = 0; i <= n; i++)
        anc[i][j] = anc[anc[i][j-1]][j-1];
}
 
int lca (int u, int v) {
    if (h[u] < h[v]) swap(u, v);
    for (int j = K; j >= 0; j--) if (h[anc[u][j]] >= h[v]) {
        u = anc[u][j];
    }
    if (u == v) return u;
    for (int j = K; j >= 0; j--) if (anc[u][j] != anc[v][j]) {
        u = anc[u][j];
        v = anc[v][j];
    }
    return anc[u][0];
}
 
int dist (int u, int v) {
    return h[u] + h[v] - 2*h[lca(u, v)];
}
 
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    memset(p, -1, sizeof(p));
    memset(anc, -1, sizeof(anc));
    cin >> n;
    for(int i = 0; i < n; i++){
        cin >> k[i];
        for(int j = 0; j < k[i]; j++){
            point u;
            cin >> u.x >> u.y;
            hull[i].pb(u);
        }
        //sort lex hull to make most left point to have index 0
        sort_lex_hull(hull[i]);
        //if(!((hull[i][1].x < hull[i][2].x) or (hull[i][1].x == hull[i][2].x and hull[i][1].y > hull[i][2].y))) swap(hull[i][1], hull[i][2]);
            
        low[i].ini = hull[i][0];
        low[i].id_ini = 0;
        end_hull[i] = {point(-LINF, -LINF), -1};
        //search for point that ends lower hull
        //end_hull[i] = point that will mark the end of the hull so we can process the polygon in the sweep line
        for(int j = 0; j < k[i]; j++){
            point u = hull[i][j];
            if((u.x > low[i].fim.x) or (u.x == low[i].fim.x and u.y < low[i].fim.y)) low[i].fim = u, low[i].id_fim = j;
            end_hull[i] = max(end_hull[i], {u, j});
        }
    }
    is_simple_polygon();
    //for all nodes with parent add parent to the nodes that depend on them
    while(!paired.empty()){
        auto cur = paired.begin();
        for(auto v : par_upd[*cur]){
            p[v] = p[*cur];
            paired.insert(v);
        }
        par_upd[*cur].clear();
        paired.erase(cur);
    }
    //generate graph
    //n = virtual node;
    for(int i = 0; i < n; i++){
        if(p[i] != -1){
            adj[p[i]].pb(i);
        }
        else{
            adj[n].pb(i);
        }
    }
    //generate lca
    build();
    // ans = longest path + longest distance between node from longest path and any other from graph
    int d = 0;
    for(int i = 0; i <= n; i++){
        d = max(d, dist(ans.nd, i));
    }
    cout << ans.st + d << "\n";
    return 0;
}