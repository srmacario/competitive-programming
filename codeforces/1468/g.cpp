#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

typedef long long ll;
typedef double ld;
typedef pair<int,int> pii;
typedef pair<int, pii> piii;
typedef pair<ll,ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-9, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9+7;
const int N = 2e5+5;

typedef double type;

bool ge(type x, type y) { return x + EPS > y; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type x, type y) : x(x), y(y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x+p.x, y+p.y); }
    point operator -(point p) { return point(x-p.x, y-p.y); }

    point operator *(type k) { return point(k*x, k*y); }
    point operator /(type k) { return point(x/k, y/k); }

    type operator *(point p) { return x*p.x + y*p.y; }
    type operator %(point p) { return x*p.y - y*p.x; }

    bool operator ==(point p) { return x == p.x and y == p.y; }
    bool operator !=(point p) { return x != p.x  or y != p.y; }
    bool operator <(const point p) const { return (x < p.x) or (x == p.x and y < p.y); }

    // o is the origin, p is another point
    // dir == +1 => p is clockwise from this
    // dir ==  0 => p is colinear with this
    // dir == -1 => p is counterclockwise from this
    int dir(point o, point p) {
        type x = (*this - o) % (p - o);
        return ge(x,0) - le(x,0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and
            ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x*x + y*y); }
    type abs2() { return x*x + y*y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    /*// Project point on vector y
    point project(point q) { return q * ((*this * q) / (q * q)); }

    // Project point on line generated by points x and y
    point project(point p, point q) { return p + (*this - p).project(q-p); }

    ld dist_line(point p, point q) { return dist(project(p, q)); }

    ld dist_seg(point p, point q) {
        return project(p, q).on_seg(p, q) ? dist_line(p, q) :  min(dist(p), dist(q)));
    }*/

    point rotate(ld sin, ld cos) { return point(cos*x-sin*y, sin*x+cos*y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }
    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.x / p.abs(), p.y / p.abs()); }
};

ostream &operator<<(ostream &os, const point &p) {
  os << "(" << p.x << "," << p.y << ")"; 
  return os;
}

int direction(point o, point p, point q) { return p.dir(o, q); }

point lines_intersect(point p, point q, point a, point b) {
    point r = q-p, s = b-a, c(p%q, a%b);
    if (eq(r%s,0)) return point(INF, INF);
    return point(point(r.x, s.x) % c, point(r.y, s.y) % c) / (r%s);
}

point p[N];

int main(){
    int n,h;
    scanf("%d %d",&n,&h);
    priority_queue <pair<pair<int,ld>,int>> pq;
    for(int i=0;i<n;i++){
        scanf("%lf %lf",&p[i].x, &p[i].y);
    }
    point eye = point(p[n-1].x,p[n-1].y+h);
    point eixo = point(1,0);
    for(int i=0;i<n;i++){
        //create priority queue with the greatest "barrier" in the moment
        point v = (eye-p[i]);
        //normalize vector
        v = v/v.abs();
        //calculating cos
        ld angle = v*eixo;
        int dir = 0;
        //if v.y is negative, means the point is above the eye
        //dir = 1 above, dir = 1 below
        //above comes first in order
        //to sort between above ones, use negative cos  
        if(v.y < -EPS) dir = 1, angle = -angle;
        pq.push({{dir,angle},-i});
    }
    ld ans = 0;
    for(int i=0;i<n-1;i++){
        bool walk = false;
        //empty queue until reaches a barrier greater than i
        while(pq.top().nd >= -i){
            //if while emptying the queue the point is not removed, it means the next barrier blocks all vision  
            if(pq.top().nd == -i) walk = true;
            //if is removed barrier only blocks partial (maybe nothing)
            pq.pop();
        }
        if(walk){
            int nxt = -pq.top().nd;
            point stop = lines_intersect(p[i],p[i+1],eye,p[nxt]);
            //corner case, collinear
            if(stop.x == INF and stop.y == INF) stop = p[i+1];
            ans += (stop-p[i]).abs();
        }
    }
    printf("%.10lf\n",ans);
    return 0;
}